package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"database/sql"
	"fmt"
	"login-system/graph/generated"
	"login-system/graph/model"
	"login-system/internal/jwtmanager"
	"login-system/internal/middleware"
	"os"

	"golang.org/x/crypto/bcrypt"
	"google.golang.org/api/idtoken"
)

// Register a new user
func (r *mutationResolver) Register(ctx context.Context, name string, email string, password string) (*model.User, error) {
	// Check if user already exists
	var exists int
	var googleRegistered bool
	err := r.DB.QueryRow("SELECT COUNT(1), COALESCE(registered_with_google, FALSE) FROM users WHERE email=$1 GROUP BY registered_with_google", email).Scan(&exists, &googleRegistered)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	if exists > 0 {
		if googleRegistered {
			return nil, fmt.Errorf("This email is already registered via Google. Please sign in with Google and set a password to enable email login.")
		}
		return nil, fmt.Errorf("Email is already in use.")
	}

	// Hash password
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Insert new user
	var user model.User
	err = r.DB.QueryRow(`
        INSERT INTO users (name, email, password_hash, registered_with_google, has_password)
        VALUES ($1, $2, $3, FALSE, TRUE)
        RETURNING id, name, email, registered_with_google, has_password
    `, name, email, string(hashed)).Scan(&user.ID, &user.Name, &user.Email, &user.RegisteredWithGoogle, &user.HasPassword)

	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Login a user with email and password
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user model.User
	var hash sql.NullString
	err := r.DB.QueryRow(`
        SELECT id, name, email, password_hash, registered_with_google, has_password
        FROM users WHERE email=$1
    `, email).Scan(&user.ID, &user.Name, &user.Email, &hash, &user.RegisteredWithGoogle, &user.HasPassword)

	if err != nil {
		return nil, fmt.Errorf("No user with that email")
	}
	if user.RegisteredWithGoogle && !user.HasPassword {
		return nil, fmt.Errorf("This account is registered via Google. Please sign in with Google and set a password to enable email login.")
	}
	if !user.HasPassword || !hash.Valid || hash.String == "" {
		return nil, fmt.Errorf("Password not set for this account.")
	}
	if err := bcrypt.CompareHashAndPassword([]byte(hash.String), []byte(password)); err != nil {
		return nil, fmt.Errorf("Incorrect password")
	}
	token, err := jwtmanager.GenerateJWT(user.ID, user.Email)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: token, User: &user}, nil
}

// GoogleAuth handles Google Sign-In authentication
func (r *mutationResolver) GoogleAuth(ctx context.Context, idToken string) (*model.AuthPayload, error) {
	googleClientID := os.Getenv("GOOGLE_CLIENT_ID")
	payload, err := idtoken.Validate(ctx, idToken, googleClientID)
	if err != nil {
		return nil, fmt.Errorf("Invalid Google token: %v", err)
	}
	email, _ := payload.Claims["email"].(string)
	name, _ := payload.Claims["name"].(string)
	sub, _ := payload.Claims["sub"].(string) // Google's unique user ID

	// Try to find user by email
	var user model.User
	err = r.DB.QueryRow("SELECT id, name, email, google_id, registered_with_google, has_password FROM users WHERE email=$1", email).
		Scan(&user.ID, &user.Name, &user.Email, &user.GoogleID, &user.RegisteredWithGoogle, &user.HasPassword)

	if err == sql.ErrNoRows {
		// Create new user
		err = r.DB.QueryRow(`
            INSERT INTO users (name, email, google_id, registered_with_google, has_password)
            VALUES ($1, $2, $3, TRUE, FALSE)
            RETURNING id, name, email, google_id, registered_with_google, has_password
        `, name, email, sub).Scan(&user.ID, &user.Name, &user.Email, &user.GoogleID, &user.RegisteredWithGoogle, &user.HasPassword)
		if err != nil {
			return nil, err
		}
	} else if err != nil {
		return nil, err
	}

	// Successful login (issue JWT)
	token, err := jwtmanager.GenerateJWT(user.ID, user.Email)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: token, User: &user}, nil
}

// SetPassword allows a user to set or change their password
func (r *mutationResolver) SetPassword(ctx context.Context, password string) (bool, error) {
	userID := middleware.GetUserIDFromCtx(ctx)
	if userID == 0 {
		return false, fmt.Errorf("Not authenticated")
	}
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return false, err
	}
	_, err = r.DB.Exec("UPDATE users SET password_hash=$1, has_password=TRUE WHERE id=$2", string(hashed), userID)
	return err == nil, err
}

// BindPasskey allows a user to bind a passkey to their account
func (r *mutationResolver) BindPasskey(ctx context.Context, passkeyID string, publicKey string) (bool, error) {
	userID := middleware.GetUserIDFromCtx(ctx)
	if userID == 0 {
		return false, fmt.Errorf("Not authenticated")
	}
	// Insert new passkey (allow multiple per user)
	_, err := r.DB.Exec(`
        INSERT INTO user_passkeys (user_id, passkey_id, public_key)
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, passkey_id) DO NOTHING
    `, userID, passkeyID, publicKey)
	return err == nil, err
}

// PasskeyLogin allows a user to log in using a passkey
func (r *mutationResolver) PasskeyLogin(ctx context.Context, passkeyID string, challengeResponse string) (*model.AuthPayload, error) {
	// 1. Lookup user_id by passkeyID
	var user model.User
	err := r.DB.QueryRow(`
        SELECT u.id, u.name, u.email, u.registered_with_google, u.has_password
        FROM users u
        JOIN user_passkeys pk ON pk.user_id = u.id
        WHERE pk.passkey_id = $1
    `, passkeyID).Scan(&user.ID, &user.Name, &user.Email, &user.RegisteredWithGoogle, &user.HasPassword)
	if err != nil {
		return nil, fmt.Errorf("No user with that passkey")
	}

	// 2. Validate challengeResponse with WebAuthn library/service (pseudo)
	// if !ValidatePasskeyChallenge(passkeyID, challengeResponse) {
	//     return nil, fmt.Errorf("Invalid passkey authentication")
	// }

	// 3. Issue JWT
	token, err := jwtmanager.GenerateJWT(user.ID, user.Email)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: token, User: &user}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
